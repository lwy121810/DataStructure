<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <!-- 红黑树的规则
        1. 每个节点要么是黑色要么是红色
        2. 根节点是黑色
        3. 每个叶子节点都是黑色的空节点(NIL节点) 
        4. 每个红色节点的两个子节点都是黑节点（每个节点到根节点的路径上不可能有两个连续的红色节点）
        5. 每个节点到叶子节点的所有路径上有相同数目的黑色节点

        > 可以引申出来：每个红色节点的都有两个黑色节点，且红色节点的子节点都是黑色的
        > 黑色节点的子节点可以是红色的，也可以是黑色的，可以两个节点都是黑色的，也可以都是红色的

        !NOTE：红黑树的关键特性：
        从根到叶子的最长可能路径，不会超过最短可能路径的两倍，这就保证了树基本是平衡的
        虽然没有做到绝对平衡，但是保证了在最坏的情况下 依然是高效的

        为什么根到叶子节点的最长路径不可能超过最短路径的两倍？
        1.因为根节点和叶子节点一定都是黑色的，而且根到叶子节点的路径上不可能有两个连续的红色节点
        所以就决定了「路径上的红色节点最多也不可能超过黑色节点的数量」，
        而特性5决定了每个路径上的黑色节点
        的数量是相同的，即最短路径的黑色节点数和最长路径的黑色节点数是一样的，

        所以最长路径的长度不可能会大于最短路径的两倍
     -->

     <!-- 插入新节点 -->
     <!--
         插入节点之后 树可能不再符合红黑树的规则，为了树符合规则需要进行 
        变色 - 左旋转 - 右旋转

        变色：为了重新符合规则，尝试把红色变黑色，或者把黑色变为红色
        左旋转：逆时针旋转红黑树的两个节点，使父节点被自己的右节点取代，
        右旋转：顺时针旋转红黑树的两个节点


         当插入新节点的时候，新节点默认为「红色」
         因为插入红色节点有可能不需要改变树的结构也满足红黑树的规则，
         插入黑色肯定不满足，因为红黑树每个路径上的黑色节点的数量是相同的，插入黑节点就导致黑色节点的数量不同，需要调整红黑树
      -->


      <!-- 插入操作 N：新插入的节点 P：N的父节点 G：N的祖父节点 U：P的兄弟节点，N的叔叔节点
        1.情况一
            新节点N位于树的根上，没有父节点
            
            操作：直接将N变为黑色

        2.情况二
            P节点是黑色

            操作：新插入N 所有的都不需要动 就符合红黑树的规则
        3.情况三
            P红U红G黑

            操作：P黑U黑G红 G如果是根节点的话还需要将G变为黑色才能符合规则

        4.情况四
            P红U黑G黑 N是左节点

            操作：P黑 G红 U不变 以P为根右旋转（在旋转之前即使符合规则也要进行旋转）

        5.情况五
            P红U黑G黑，N是右节点

            操作：
                1.以P为根 进行左旋转（左旋转之后N就成了P的父节点）
                2.将P及其子节点看作是新插入的节点考虑即可(即情况四)
       --> 

       <!--  -->
</body>
</html>