<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <!-- 
        哈希化：    将大数字转化为 数组范围内下标的过程称之为哈希化
        哈希函数：  通常我们将单词转为大数字，大数字哈希化的过程封装到一个函数中，该函数就是哈希函数
        哈希表：    最终将数据插入到的这个 数组，对整个结构的封装，称为哈希表
     -->
     <!-- 
         哈希化后的下标有可能重复， 重复问题的解决方法：
         1. 链地址法（拉链法）：数组中的下标值不再存储元素，而是一个数组或者链表，数组/链表再存储对应的元素
         2. 开放地址法：寻找空白的单元格来存放重复的数据，比如现在插入32，应该在下标为2的位置 
                      但是这时候下标2的位置已经有数据了，就寻找下一个空白的位置存放该数据
                探索空白位置的方法：
                    1.线性探测：步长为1 逐步查找空白单位
                    2.二次探测
                    3.再哈希法   
            查询：查询对应下标的元素，如果该下标的值不是要查找的值，则逐步往下查找，直到找到或者查找到空白单
            删除：注意点就是删除元素之后不能将该下标的内容设置为null

            线性探测的问题：如果之前的数据是连续插入的，那么新插入的数据就要探测很长的距离，
                         比如下标2到9都有数据，现在新插入数据到2，就需要探测很多的下标

            二次探测：主要优化的是探测的步长，线性探测步长为1，比如从下标x开始，那线性探测就是x+1，x+2，x+3依次探测
                    二次探测是x+1^2，x+2^2，x+3^2的探测，这样一次可以探测比较长的步长，避免聚集带来的影响
                问题：还是有可能会造成步长不一样的聚集，还是会影响效率（比连续数字会小一些）
        
           为了解决线性探测/二次探测中无论步长为1还是步长加平方中存在的问题，还有一种最常用的解决方案：再哈希法 
        
        再哈希法：需要产生一种「依赖关键字的探测序列」，而不是每个关键字都一样，这样，即使不同的关键字映射到相同
                的下标，也可以使用不同的探测序列。

                做法：把关键字用「另一个哈希函数做一次哈希化」，用这次哈希化的结果作为步长
                对于指定的关键字。步长再整个探测中是不变的，但是不同的关键字的步长不一样
            
                第二次哈希需要具备如下条件
                    1。和「第一个哈希函数不同」，不然结果还是原来的位置
                    2. 不能输出为0，否则没有步长，算法进入死循环
                
                    计算机专家给出的算法：
                    stepSize = constant - (key % constant)
                    其中constant是质数，且小于数组的长度
       -->

       <!-- 哈希化的效率 -->
       <!-- 
           哈希表中执行插入和搜索的效率是非常高的
           如果没有产生冲突，效率会更高
           如果发生冲突，存取时间就取决于后来的探测长度

           平均探测长度和平均存取时长取决于「填装因子」，随着填装因子变大，探测长度也越来越长
           随着填装因子变大，效率变低的问题，再不同的开放地址法中比链地址法更严重
        -->
        <!-- 填装因子 Load Factor -->
        <!-- 
            LoadFactor表示当前哈希表中「已经包含的数据项」和「哈希表的长度」的比值
            LaodFactor = 总数据项/哈希表长度

            开放地址法的填装因子最大为1，因为要插入数据必须要有空白单位，没有的话就不能再插入
            链地址法：填装因子可以大于1，因为拉链法可以无限延伸下去，只要你愿意（后面效率就会变低）
         -->
         <!-- 
             线性探测时，探测序列(P)和填装因子(L)的关系
                对成功的查找：  P=(1+1/(1-L)^2)/2
                对不成功的查找： P=(1+1/(1-L))/2
          -->
          <!-- 
              好的哈希函数应该尽可能让计算的过程变得简单，提高计算的效率
              哈希表的主要优点就是速度，提高速度的一个方法就是让哈希函数种尽可能少的有乘法和除法（性能比较低）

              好的哈希函数的优点
              1.快速计算
                需要快速计算来获取元素对应的hashCode
              2.均匀的分布
                哈希表中，无论是链地址法还是开放地址法，当多个元素映射到相同位置时，都会影响效率
                所以优秀的哈希函数应该尽可能的将元素映射到不同的位置，让元素在哈希表中均匀分布

           -->
           <!-- 均匀分布 

                我们在「使用常量的地方」，尽量使用「质数」，可以让哈希表分布的更加均匀
            
            质数的使用：
                1. 哈希表的长度
                2. N次幂的底数
            -->
            <!-- Java中的哈希表使用的是链地址法
                链地址法中质数没那么重要，Java中甚至故意使用了2的N次幂

                HashMap的初始长度为16(2^4)，每次自动扩展长度必须是2的N次幂 16 -> 32 -> 64
                这是为了服务key映射到index的算法
            
                HashMap中为了提高效率，采用了位运算（&）的方式：
                // HashCode: key对应的数字 length-1哈希表的最大下标
                计算index的公示：index = HashCode & (Length - 1)

                位运算相对于模运算效率更高
             -->
    <script>
        // 设计哈希函数
        // 1. 将字符串转为较大的数字：hashCode
        // 2. 将大的数字hashCode压缩到数组范围(size就是数组的长度)
        function hashFunc(str, size){
            // 1.定义hashCode变量
            var hashCode = 0

            // 2. 霍纳算法，计算hashCode的值
            for (let i = 0; i < str.length; i++) {
                // 常量使用质数 常使用37
                hashCode = 37 * hashCode + str.charCodeAt(i)
            }
            // 3. 模运算 压缩hashCode到数组范围
            var index = hashCode % size
            return index
        }

        alert(hashFunc('abc', 7))
        alert(hashFunc('mbc', 7))
        alert(hashFunc('nbc', 7))

    </script>
</body>
</html>