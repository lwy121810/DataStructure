<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        function ArrayList() {
            this.array = []

            // 将数据插入到数组中
            ArrayList.prototype.insert = function (item) {
                this.array.push(item)
            }
            ArrayList.prototype.toString = function () {
                return this.array.join('-')
            }
            ArrayList.prototype.swap = function (m, n) {
                var temp = this.array[m]
                this.array[m] = this.array[n]
                this.array[n] = temp
            }
            // 实现排序算法
            // 冒泡排序
            // 两两比较大小，后一个大于前面的话就交换位置 这样经过一次循环 最大的一个就排到了最后
            // 冒泡排序效率：
            // 比较次数：O(n^2)
            // 交换次数：O(n^2)
            ArrayList.prototype.bubbleSort = function () {
                var length = this.array.length;

                // 第一个循环需要比较length-1次 最大的排到最后
                // 第二次的话最后的就不需要要比较(已经是最大)
                // 也就是说两两比较的次数是逐次递减的
                // 用最外层的循环来决定比较的次数
                for (var j = length - 1; j >= 0; j--) {
                    // 这层循环是两两比较 最后最大的一个排到最后
                    for (var i = 0; i < j; i++) {
                        // 比较大小
                        if (this.array[i] > this.array[i + 1]) {
                            // 如果前一个位置的数据比后一个大
                            // 他们两个交换位置
                            this.swap(i, i + 1)
                        }
                    }
                }
            }


            // 选择排序：每次选择最小的一个排到最前面
            // 选择排序的效率：
            // 比较次数：O(n^2)
            // 交换次数：O(n) 每次遍历只交换一次 所以认为选择排序效率是高于冒泡
            ArrayList.prototype.selectionSort = function () {
                // 长度
                var length = this.array.length
                for (var j = 0; j < length - 1; j++) {
                    // 第一次循环比较length - 1次
                    // 第二次循环比较length - 2次
                    // ...
                    
                    // 每次循环默认最小值的下标就是当前循环的第一个
                    var minIndex = j
                    for (var i = minIndex + 1; i < length; i++) {
                        if (this.array[minIndex] > this.array[i]) {
                            // 记录最小值的下标
                            minIndex = i
                        }
                    }
                    // 这里已经得到最小值的下标
                    // 和第一个进行交换
                    this.swap(minIndex, j)
                }
            }


            // 插入排序

            // 希尔排序

            // 快速排序


        }

        // 初始化数据项
        var list = new ArrayList()

        list.insert(3)
        list.insert(6)
        list.insert(4)
        list.insert(2)
        list.insert(11)
        list.insert(10)
        list.insert(5)

        alert(list)

        // 测试冒泡排序
        list.bubbleSort()
        alert(list) // 2,3,4,5,6,10,11

        list.selectionSort()
        alert(list)
    </script>
</body>

</html>